%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,danish]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Sonny]{fncychap}
\ChNameVar{\Large\normalfont\sffamily}
\ChTitleVar{\Large\normalfont\sffamily}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}




\title{Formel Samling}
\date{03. jan., 2024}
\release{1.0}
\author{Frederik Hansen}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Udgave}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope


\chapter{Algorithmer}
\label{\detokenize{Algorithmer/index:algorithmer}}\label{\detokenize{Algorithmer/index::doc}}
\sphinxstepscope


\section{Hashmaps / Hash tables}
\label{\detokenize{Algorithmer/Hashmaps:hashmaps-hash-tables}}\label{\detokenize{Algorithmer/Hashmaps::doc}}
\sphinxAtStartPar
Hashmaps er en datastruktur hvor posistionen af dataen i memory er beskrevet gennem en funktion.


\subsection{key}
\label{\detokenize{Algorithmer/Hashmaps:key}}
\sphinxAtStartPar
det data der beskriver inputtet i din hashing funktion


\subsection{index mapping ( trivial hashing )}
\label{\detokenize{Algorithmer/Hashmaps:index-mapping-trivial-hashing}}
\sphinxAtStartPar
beskriver hashing functionen f(x)=x altså er din key lig med posistionen i memory


\subsection{collision}
\label{\detokenize{Algorithmer/Hashmaps:collision}}
\sphinxAtStartPar
hvis en funktion retunere den samme område i memory ved 2 forskellige keys


\subsection{seperate chaining}
\label{\detokenize{Algorithmer/Hashmaps:seperate-chaining}}
\sphinxAtStartPar
en måde at løse collisions problemer ved at erstate indgangen i memory med en liste som indeholde begge værdier der skal være på denne key.


\subsection{Open addressing}
\label{\detokenize{Algorithmer/Hashmaps:open-addressing}}
\sphinxAtStartPar
open adressing betyder at din indang i hastabellen ikke behøver at være det præcise resultat af hash functionen. Når man ændre på hvilken posistion noget ligger på kalder man det probing

\sphinxAtStartPar
\sphinxstyleemphasis{VIGTIGT} Når der laves open adressing skal den originale key gemmes sammen med data’en således at programmet kan chekke om der skal laves probing eller ej.


\subsubsection{linear probing}
\label{\detokenize{Algorithmer/Hashmaps:linear-probing}}
\sphinxAtStartPar
en probing methode hvor man bare tager den næste frie plads i memory


\subsubsection{quadratic probing ( mid\sphinxhyphen{}square method )}
\label{\detokenize{Algorithmer/Hashmaps:quadratic-probing-mid-square-method}}
\sphinxAtStartPar
her søger man igennem index+x\(\sp{\text{2}}\) hvor x stiger med 1 indtil man finder en plads


\subsubsection{dobbelt hashing}
\label{\detokenize{Algorithmer/Hashmaps:dobbelt-hashing}}
\sphinxAtStartPar
ved dobbelt hashing bruges en anden hashing function som sådan til at lave probing. dette gøres ved formlen
h1(key)+h2(key)*x hvor x stiger med 1 indtil en plads er fundet.


\subsection{universal hashing}
\label{\detokenize{Algorithmer/Hashmaps:universal-hashing}}
\sphinxAtStartPar
Når man laver universal hashing vælges en tilfældig hashing funktion hver gange et nyt table laves, på denne måde kan en malicius actor ikke vide hvilken hashing algoritme er valgt.

\sphinxstepscope


\section{Tids og størrelses kompleksitet}
\label{\detokenize{Algorithmer/Kompleksitet:tids-og-storrelses-kompleksitet}}\label{\detokenize{Algorithmer/Kompleksitet::doc}}

\subsection{big O thetha and omega notation}
\label{\detokenize{Algorithmer/Kompleksitet:big-o-thetha-and-omega-notation}}
\sphinxAtStartPar
\sphinxincludegraphics{{mypic}.png}
\sphinxincludegraphics{{dQXTubC}.png}


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
S.No.
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Big O
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Big Omega (Ω)
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Big Theta (Θ)
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
1.
&
\sphinxAtStartPar
It is like (\textless{}=) rate of growth of an algorithm is less than or equal to a specific value. 
&
\sphinxAtStartPar
It is like (\textgreater{}=) rate of growth is greater than or equal to a specified value.
&
\sphinxAtStartPar
It is like (==) meaning the rate of growth is equal to a specified value.
\\
\sphinxhline
\sphinxAtStartPar
2.
&
\sphinxAtStartPar
The upper bound of algorithm is represented by Big O notation. Only the above function is bounded by Big O. Asymptotic upper bound is  given by Big O notation.
&
\sphinxAtStartPar
The algorithm’s lower bound is represented by Omega notation. The asymptotic lower bound is given by Omega notation.
&
\sphinxAtStartPar
The bounding of function from above and below is represented by theta notation. The exact asymptotic behavior is done by this theta notation.
\\
\sphinxhline
\sphinxAtStartPar
3.
&
\sphinxAtStartPar
Big O \textendash{} Upper Bound
&
\sphinxAtStartPar
Big Omega (Ω) \textendash{} Lower Bound
&
\sphinxAtStartPar
Big Theta (Θ) \textendash{} Tight Bound
\\
\sphinxhline
\sphinxAtStartPar
4.
&
\sphinxAtStartPar
It is define as upper bound and upper bound on an algorithm is the most amount of time required ( the worst case performance).
&
\sphinxAtStartPar
It is define as lower bound and lower bound on an algorithm is the least amount of time required ( the most efficient way possible, in other words best case).
&
\sphinxAtStartPar
It is define as tightest bound and tightest bound is the best of all the worst case times that the algorithm can take.
\\
\sphinxhline
\sphinxAtStartPar
5.
&
\sphinxAtStartPar
Mathematically: Big Oh is 0 \textless{}= f(n) \textless{}= Cg(n) for all n \textgreater{}= n0
&
\sphinxAtStartPar
Mathematically: Big Omega is 0 \textless{}= Cg(n) \textless{}= f(n) for all n \textgreater{}= n0
&
\sphinxAtStartPar
Mathematically \textendash{} Big Theta is 0 \textless{}= C2g(n) \textless{}= f(n) \textless{}= C1g(n) for n \textgreater{}= n0
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{little o theta and omega notation}
\label{\detokenize{Algorithmer/Kompleksitet:little-o-theta-and-omega-notation}}
\sphinxAtStartPar
lille notation har som sådan de samme regler som big notation, med den undtagelse at definitaionen skal gælde for alle værider af n ( altså alle steder på funktionen ) og ikke kun i et enkelt scenarie.


\subsection{rekursive funktioner}
\label{\detokenize{Algorithmer/Kompleksitet:rekursive-funktioner}}
\sphinxAtStartPar
rekursive funtioner er funktioner der indeholder sig selv. fx:
t(n) = 1+t(2/n)


\subsection{Master Theorem}
\label{\detokenize{Algorithmer/Kompleksitet:master-theorem}}
\sphinxAtStartPar
\sphinxincludegraphics{{coKFB7D}.png}

\sphinxAtStartPar
der findes også en udvidet master Theorem

\sphinxAtStartPar
ud fra formlen

\sphinxAtStartPar
T(n) = aT(n/b)+O(n\textasciicircum{}k*log\_P(n))

\sphinxAtStartPar
her gælder:

\sphinxAtStartPar
if a \textgreater{} bk, then T(n) = θ(nlogba)
if a = bk, then
(a) if p \textgreater{} \sphinxhyphen{}1, then T(n) = θ(nlogba logp+1n)
(b) if p = \sphinxhyphen{}1, then T(n) = θ(nlogba loglogn)
(c) if p \textless{} \sphinxhyphen{}1, then T(n) = θ(nlogba)

\sphinxAtStartPar
if a \textless{} bk, then
(a) if p \textgreater{}= 0, then T(n) = θ(nk logpn)
(b) if p \textless{} 0, then T(n) = θ(nk)


\subsection{algoritme cheat sheet}
\label{\detokenize{Algorithmer/Kompleksitet:algoritme-cheat-sheet}}

\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
Algorithm
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Best Case
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Average Case
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Worst Case
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
Selection Sort
&
\sphinxAtStartPar
O(n\textasciicircum{}2)
&
\sphinxAtStartPar
O(n\textasciicircum{}2)
&
\sphinxAtStartPar
O(n\textasciicircum{}2)
\\
\sphinxhline
\sphinxAtStartPar
Bubble Sort
&
\sphinxAtStartPar
O(n)
&
\sphinxAtStartPar
O(n\textasciicircum{}2)
&
\sphinxAtStartPar
O(n\textasciicircum{}2)
\\
\sphinxhline
\sphinxAtStartPar
Insertion Sort
&
\sphinxAtStartPar
O(n)
&
\sphinxAtStartPar
O(n\textasciicircum{}2)
&
\sphinxAtStartPar
O(n\textasciicircum{}2)
\\
\sphinxhline
\sphinxAtStartPar
Tree Sort
&
\sphinxAtStartPar
O(nlogn)
&
\sphinxAtStartPar
O(nlogn)
&
\sphinxAtStartPar
O(n\textasciicircum{}2)
\\
\sphinxhline
\sphinxAtStartPar
Radix Sort
&
\sphinxAtStartPar
O(dn)
&
\sphinxAtStartPar
O(dn)
&
\sphinxAtStartPar
O(dn)
\\
\sphinxhline
\sphinxAtStartPar
Merge Sort
&
\sphinxAtStartPar
O(nlogn)
&
\sphinxAtStartPar
O(nlogn)
&
\sphinxAtStartPar
O(nlogn)
\\
\sphinxhline
\sphinxAtStartPar
Heap Sort
&
\sphinxAtStartPar
O(nlogn)
&
\sphinxAtStartPar
O(nlogn)
&
\sphinxAtStartPar
O(nlogn)
\\
\sphinxhline
\sphinxAtStartPar
Quick Sort
&
\sphinxAtStartPar
O(nlogn)
&
\sphinxAtStartPar
O(nlogn)
&
\sphinxAtStartPar
O(n\textasciicircum{}2)
\\
\sphinxhline
\sphinxAtStartPar
Bucket Sort
&
\sphinxAtStartPar
O(n+k)
&
\sphinxAtStartPar
O(n+k)
&
\sphinxAtStartPar
O(n\textasciicircum{}2)
\\
\sphinxhline
\sphinxAtStartPar
Counting Sort
&
\sphinxAtStartPar
O(n+k)
&
\sphinxAtStartPar
O(n+k)
&
\sphinxAtStartPar
O(n+k)
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxstepscope


\section{Sorterings algorithmer}
\label{\detokenize{Algorithmer/Sorting:sorterings-algorithmer}}\label{\detokenize{Algorithmer/Sorting::doc}}

\subsection{Heapsort}
\label{\detokenize{Algorithmer/Sorting:heapsort}}
\sphinxAtStartPar
Max\sphinxhyphen{}Heapify sort
seudo kode
A er arrayet vores Heap er gemt i
i er vores index i heap

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Max}\PYG{o}{\PYGZhy{}}\PYG{n}{Heapify} \PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}

\PYG{n}{l} \PYG{o}{=} \PYG{n}{LEFT}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} 
\PYG{n}{r} \PYG{o}{=} \PYG{n}{RIGHT}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{l} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{heap}\PYG{o}{\PYGZhy{}}\PYG{n}{size} \PYG{o+ow}{and} \PYG{n}{A}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{n}{largest} \PYG{o}{=} \PYG{n}{l}
\PYG{k}{else} \PYG{n}{largest} \PYG{o}{=} \PYG{n}{i}
\PYG{k}{if} \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{heap}\PYG{o}{\PYGZhy{}}\PYG{n}{size} \PYG{o+ow}{and} \PYG{n}{A}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]} \PYG{o}{\PYGZgt{}} \PYG{n}{A}\PYG{p}{[}\PYG{n}{largest}\PYG{p}{]}
    \PYG{n}{largest} \PYG{o}{=} \PYG{n}{r}
\PYG{k}{if} \PYG{n}{largest} \PYG{o}{!=} \PYG{n}{i}
    \PYG{n}{exchange} \PYG{n}{A}\PYG{p}{[}\PYG{n}{largest}\PYG{p}{]} \PYG{o+ow}{and} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{n}{Max}\PYG{o}{\PYGZhy{}}\PYG{n}{Heapify}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{largest}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
Min\sphinxhyphen{}Heapify sort
seudo kode

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Min}\PYG{o}{\PYGZhy{}}\PYG{n}{Heapify} \PYG{p}{(}\PYG{n}{A}\PYG{p}{,} \PYG{n}{i}\PYG{p}{)}

\PYG{n}{l} \PYG{o}{=} \PYG{n}{LEFT}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)} 
\PYG{n}{r} \PYG{o}{=} \PYG{n}{RIGHT}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}

\PYG{k}{if} \PYG{n}{l} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{heap}\PYG{o}{\PYGZhy{}}\PYG{n}{size} \PYG{o+ow}{and} \PYG{n}{A}\PYG{p}{[}\PYG{n}{l}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{n}{smallest} \PYG{o}{=} \PYG{n}{l}
\PYG{k}{else} \PYG{n}{smallest} \PYG{o}{=} \PYG{n}{i}
\PYG{k}{if} \PYG{n}{r} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{A}\PYG{o}{.}\PYG{n}{heap}\PYG{o}{\PYGZhy{}}\PYG{n}{size} \PYG{o+ow}{and} \PYG{n}{A}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]} \PYG{o}{\PYGZlt{}} \PYG{n}{A}\PYG{p}{[}\PYG{n}{largest}\PYG{p}{]}
    \PYG{n}{smallest} \PYG{o}{=} \PYG{n}{r}
\PYG{k}{if} \PYG{n}{smallest} \PYG{o}{!=} \PYG{n}{i}
    \PYG{n}{exchange} \PYG{n}{A}\PYG{p}{[}\PYG{n}{smallest}\PYG{p}{]} \PYG{o+ow}{and} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}
    \PYG{n}{Min}\PYG{o}{\PYGZhy{}}\PYG{n}{Heapify}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{smallest}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Quick sort}
\label{\detokenize{Algorithmer/Sorting:quick-sort}}
\sphinxAtStartPar
Quick sort is a divide and conquor algoritme

\sphinxAtStartPar
seudo kode:
A er det array der skal sorteres
p er vores første indgang i arrayet
r er den sidste indgang i arrayet

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Quicksort}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{r}\PYG{p}{)}
\PYG{k}{if} \PYG{n}{p} \PYG{o}{\PYGZlt{}} \PYG{n}{r}
    \PYG{n}{q} \PYG{o}{=} \PYG{n}{Partition}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{r}\PYG{p}{)}
    \PYG{n}{Quicksort}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{q}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}
    \PYG{n}{Quicksort}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{q}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{r}\PYG{p}{)}

\PYG{n}{Partition}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{p}\PYG{p}{,}\PYG{n}{r}\PYG{p}{)}
\PYG{n}{x}\PYG{o}{=}\PYG{n}{A}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}
\PYG{n}{i}\PYG{o}{=}\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
\PYG{k}{for} \PYG{n}{j} \PYG{o}{=} \PYG{n}{p} \PYG{n}{to} \PYG{n}{r}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}
    \PYG{k}{if} \PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]} \PYG{o}{\PYGZlt{}}\PYG{o}{=} \PYG{n}{x}
        \PYG{n}{i} \PYG{o}{=} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1} 
        \PYG{n}{exchange} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{with} \PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}
\PYG{n}{exchange} \PYG{n}{A}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{k}{with} \PYG{n}{A}\PYG{p}{[}\PYG{n}{r}\PYG{p}{]}
\PYG{k}{return} \PYG{n}{i}\PYG{o}{+}\PYG{l+m+mi}{1}
\end{sphinxVerbatim}


\subsection{Count sort}
\label{\detokenize{Algorithmer/Sorting:count-sort}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Counting} \PYG{n}{sort}\PYG{p}{(}\PYG{n}{A}\PYG{p}{,}\PYG{n}{n}\PYG{p}{,}\PYG{n}{k}\PYG{p}{)}
\PYG{n}{let} \PYG{n}{B}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{:}\PYG{n}{n}\PYG{p}{]} \PYG{o+ow}{and} \PYG{n}{C}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{:}\PYG{n}{k}\PYG{p}{]}
\PYG{k}{for} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0} \PYG{n}{to} \PYG{n}{k}
    \PYG{n}{C}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{o}{=} \PYG{n}{i}
\PYG{k}{for} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{1} \PYG{n}{to} \PYG{n}{n}
    \PYG{n}{C}\PYG{p}{[}\PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]} \PYG{o}{=} \PYG{n}{C}\PYG{p}{[}\PYG{n}{A}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]} \PYG{o}{+} \PYG{l+m+mi}{1}


\end{sphinxVerbatim}


\subsection{Radix sort}
\label{\detokenize{Algorithmer/Sorting:radix-sort}}
\sphinxAtStartPar
in radix sort you sort the numbers by the smallest digit first.

\sphinxAtStartPar
hvis alle tal i arrayet har lige mange digits er radix sort O(n)


\subsection{Bucket sort}
\label{\detokenize{Algorithmer/Sorting:bucket-sort}}
\sphinxAtStartPar
O(n\(\sp{\text{2}}\))
MEN!
Big Theta på (n)
**SHITTY SUDO CODE **

\sphinxAtStartPar
!(shitty code){[}https://i.imgur.com/1U8EpXe.png{]}
Legit den her kode er så dårligt skrevet at den legit ikke giver mening. så her er den lige i C++ /

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{/}\PYG{o}{/} \PYG{n}{Function} \PYG{n}{to} \PYG{n}{sort} \PYG{n}{arr}\PYG{p}{[}\PYG{p}{]} \PYG{n}{of}
\PYG{o}{/}\PYG{o}{/} \PYG{n}{size} \PYG{n}{n} \PYG{n}{using} \PYG{n}{bucket} \PYG{n}{sort}
\PYG{n}{void} \PYG{n}{bucketSort}\PYG{p}{(}\PYG{n+nb}{float} \PYG{n}{arr}\PYG{p}{[}\PYG{p}{]}\PYG{p}{,} \PYG{n+nb}{int} \PYG{n}{n}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
 
    \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{1}\PYG{p}{)} \PYG{n}{Create} \PYG{n}{n} \PYG{n}{empty} \PYG{n}{buckets}
    \PYG{n}{vector}\PYG{o}{\PYGZlt{}}\PYG{n+nb}{float}\PYG{o}{\PYGZgt{}} \PYG{n}{b}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{;}
 
    \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{2}\PYG{p}{)} \PYG{n}{Put} \PYG{n}{array} \PYG{n}{elements}
    \PYG{o}{/}\PYG{o}{/} \PYG{o+ow}{in} \PYG{n}{different} \PYG{n}{buckets}
    \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)} \PYG{p}{\PYGZob{}}
 
        \PYG{o}{/}\PYG{o}{/} \PYG{n}{Index} \PYG{o+ow}{in} \PYG{n}{bucket}
        \PYG{n+nb}{int} \PYG{n}{bi} \PYG{o}{=} \PYG{n}{n} \PYG{o}{*} \PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{;}
        \PYG{n}{b}\PYG{p}{[}\PYG{n}{bi}\PYG{p}{]}\PYG{o}{.}\PYG{n}{push\PYGZus{}back}\PYG{p}{(}\PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
 
    \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{3}\PYG{p}{)} \PYG{n}{Sort} \PYG{n}{individual} \PYG{n}{buckets}
    \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{n}{sort}\PYG{p}{(}\PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{begin}\PYG{p}{(}\PYG{p}{)}\PYG{p}{,} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{end}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
 
    \PYG{o}{/}\PYG{o}{/} \PYG{l+m+mi}{4}\PYG{p}{)} \PYG{n}{Concatenate} \PYG{n+nb}{all} \PYG{n}{buckets} \PYG{n}{into} \PYG{n}{arr}\PYG{p}{[}\PYG{p}{]}
    \PYG{n+nb}{int} \PYG{n}{index} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{i} \PYG{o}{\PYGZlt{}} \PYG{n}{n}\PYG{p}{;} \PYG{n}{i}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
        \PYG{k}{for} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{j} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;} \PYG{n}{j} \PYG{o}{\PYGZlt{}} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{o}{.}\PYG{n}{size}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;} \PYG{n}{j}\PYG{o}{+}\PYG{o}{+}\PYG{p}{)}
            \PYG{n}{arr}\PYG{p}{[}\PYG{n}{index}\PYG{o}{+}\PYG{o}{+}\PYG{p}{]} \PYG{o}{=} \PYG{n}{b}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxstepscope


\section{programmerings paradimer}
\label{\detokenize{Algorithmer/Dynamic:programmerings-paradimer}}\label{\detokenize{Algorithmer/Dynamic::doc}}

\subsection{Dynamic programming}
\label{\detokenize{Algorithmer/Dynamic:dynamic-programming}}
\sphinxAtStartPar
Dynamic programming er er programming uden recursion. Dette er ofte opnået ved at loope igennem en funktion flere gange og gemme resultaterne. Ofte resultere dette i en hurtigere algoritme da man kan gemme resultatet for flere funktions kald som ville give det samme resultat istedet for at køre funktionen flere gange


\subsubsection{subproblem graf (afhængligheds graf)}
\label{\detokenize{Algorithmer/Dynamic:subproblem-graf-afhaengligheds-graf}}
\sphinxAtStartPar
et recursivt problem kan beskrives som et problem med flere subproblemer. den originale funktion afhænger af løsningen af disse subproblemer. En subproblem graf viser os hvilket subproblem der ikke afhænger af nogle andre, og dermed hvilen rækkefølge subproblemerne skal løsses i.

\sphinxAtStartPar
fx hvis vi havde koden.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{function} \PYG{n}{fibonachi} \PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{n}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{n} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{n} \PYG{o}{==} \PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{return} \PYG{n}{fibonachi}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{+}\PYG{n}{fibonachi}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
hvis n = 5 fåes subproblem grafen:

\sphinxAtStartPar
\sphinxincludegraphics{{UYALrtc}.png}


\subsection{Greedy algorithms}
\label{\detokenize{Algorithmer/Dynamic:greedy-algorithms}}
\sphinxAtStartPar
En greedy algoritme der »gårdigt« vælger hvad der virker som den bedste løsning lokalt, for forhåbenligt at komme til den bedste generelle løsning.


\subsection{Divide and Conquer}
\label{\detokenize{Algorithmer/Dynamic:divide-and-conquer}}
\sphinxAtStartPar
Ved denne metode løses et eller uoverskueligt problem ved at dele det op, løse undederlene og derefter ligge resultatet sammen.

\sphinxstepscope


\section{Binær træer}
\label{\detokenize{Algorithmer/BinaryTrees:binaer-traeer}}\label{\detokenize{Algorithmer/BinaryTrees::doc}}
\sphinxAtStartPar
Binære træer er en data type hvor hver node kun har 2 børn. Dermed kan hvert »spring« beskrives med et Binært 1 eller 0

\sphinxAtStartPar
\sphinxincludegraphics{{69f63082cc520610465d18430fdcb96c8cdbe0cb}.png&f=1&nofb=1&ipt=97e67a0f0b308dc298d54a29e8ebe380cb465535a14f576d53e70fd1fc8fde4e&ipo=images}


\subsection{binær søge træ}
\label{\detokenize{Algorithmer/BinaryTrees:binaer-soge-trae}}
\sphinxAtStartPar
tal som er større end forældrene vil atid ænde til venstre i et binær træ og tal som er større end forældre vil ende til højre i et binær træ. Dette gør det nemmere at søge i, men kan dog også være træet rimlig skævt.

\sphinxAtStartPar
søge algorithmen for disse træer er oplagt:

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\PYG{n}{function} \PYG{n}{binary\PYGZus{}Search}\PYG{p}{(}\PYG{n+nb}{int} \PYG{n}{searchNumber}\PYG{p}{)}\PYG{p}{\PYGZob{}}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{node} \PYG{o}{=} \PYG{n}{searchNumber}\PYG{p}{)}\PYG{p}{\PYGZob{}}
        \PYG{k}{return} \PYG{n}{nodeIndex}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if}\PYG{p}{(}\PYG{n}{node} \PYG{o}{\PYGZgt{}} \PYG{n}{searchNumber}\PYG{p}{)}\PYG{p}{\PYGZob{}}
    \PYG{n}{go} \PYG{n}{left} \PYG{n}{on} \PYG{n}{binary} \PYG{n}{trees}
    \PYG{p}{\PYGZcb{}}

    \PYG{k}{if}\PYG{p}{(} \PYG{n}{node} \PYG{o}{\PYGZlt{}} \PYG{n}{searchNumber}\PYG{p}{)} \PYG{p}{\PYGZob{}}
    \PYG{n}{go} \PYG{n}{right} \PYG{n}{on} \PYG{n}{binary} \PYG{n}{tree}
    \PYG{p}{\PYGZcb{}}

\PYG{p}{\PYGZcb{}}

\end{sphinxVerbatim}


\subsection{Max Heap / Min Heap}
\label{\detokenize{Algorithmer/BinaryTrees:max-heap-min-heap}}
\sphinxAtStartPar
Heaps er binær træer med regler for strukturen af træet


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Max Heap}
&\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxstylestrong{Min Heap}
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
forældre \textgreater{}= børn
&
\sphinxAtStartPar
forældre \textless{}= børn
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}


\subsection{Sort Rød træer}
\label{\detokenize{Algorithmer/BinaryTrees:sort-rod-traeer}}
\sphinxAtStartPar
Sort røde træer deler nodes op i 2 farver med disse regler
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
hver node skal enten være rød eller sort

\item {} 
\sphinxAtStartPar
roden skal altid være sort

\item {} 
\sphinxAtStartPar
røde nodes må ikke have røde forældre eller børn

\item {} 
\sphinxAtStartPar
hver slut node »null« node skal være sort

\item {} 
\sphinxAtStartPar
der skal altid være den samme mængde sorte nodes mellem roden og null nodes.

\end{enumerate}

\sphinxstepscope


\section{Graf teori}
\label{\detokenize{Algorithmer/Graphs:graf-teori}}\label{\detokenize{Algorithmer/Graphs::doc}}

\section{Adjecency lists / Adjecency matrix}
\label{\detokenize{Algorithmer/Graphs:adjecency-lists-adjecency-matrix}}
\sphinxAtStartPar
en adjacency list er en liste over hvilke nodes en anden node har edges til.

\sphinxAtStartPar
i graften til Ford\sphinxhyphen{}Fulkerson eksemplet ville det fx for v2 være


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
s
&\sphinxstyletheadfamily 
\sphinxAtStartPar
v1
&\sphinxstyletheadfamily 
\sphinxAtStartPar
v2
&\sphinxstyletheadfamily 
\sphinxAtStartPar
v3
&\sphinxstyletheadfamily 
\sphinxAtStartPar
v4
&\sphinxstyletheadfamily 
\sphinxAtStartPar
g
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
1
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
disse kan være vægtet. Det betyder bare at vægten af edgen skrives i stedet for 1


\begin{savenotes}\sphinxattablestart
\sphinxthistablewithglobalstyle
\centering
\begin{tabulary}{\linewidth}[t]{TTTTTT}
\sphinxtoprule
\sphinxstyletheadfamily 
\sphinxAtStartPar
s
&\sphinxstyletheadfamily 
\sphinxAtStartPar
v1
&\sphinxstyletheadfamily 
\sphinxAtStartPar
v2
&\sphinxstyletheadfamily 
\sphinxAtStartPar
v3
&\sphinxstyletheadfamily 
\sphinxAtStartPar
v4
&\sphinxstyletheadfamily 
\sphinxAtStartPar
g
\\
\sphinxmidrule
\sphinxtableatstartofbodyhook
\sphinxAtStartPar
0
&
\sphinxAtStartPar
4
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
0
&
\sphinxAtStartPar
14
&
\sphinxAtStartPar
0
\\
\sphinxbottomrule
\end{tabulary}
\sphinxtableafterendhook\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
en Adjecency matrix er en matrice af disse lister
\sphinxincludegraphics{{68f8db9b25a5a08e250b56d683bd1a3df2d9c5f5}.jpg}


\section{dybte og bredte søgning (BFS og DFS)}
\label{\detokenize{Algorithmer/Graphs:dybte-og-bredte-sogning-bfs-og-dfs}}
\sphinxAtStartPar
\sphinxincludegraphics{{3LYTPP9}.png}
\sphinxincludegraphics{{4gJzNsJ}.png}

\sphinxAtStartPar
\sphinxincludegraphics{{dKK1LtO}.png}


\section{topological sort}
\label{\detokenize{Algorithmer/Graphs:topological-sort}}
\sphinxAtStartPar
vælg en tilfældig node. Giv den tallet 1 gå til den næste node giv den tallet 2
sæt nodes i rækkefølge efter det største tal. nodes kan godt have flere tal

\sphinxAtStartPar
\sphinxincludegraphics{{cKChxwN}.png}


\subsection{Ford\sphinxhyphen{}Fulkerson Algoritme / edmond karp}
\label{\detokenize{Algorithmer/Graphs:ford-fulkerson-algoritme-edmond-karp}}
\sphinxAtStartPar
Bruges til at finde max netværks capacitet. Kan også give dig en iden om hvor dit netværk skal fobedres for den bedste effect

\sphinxAtStartPar
\sphinxincludegraphics{{LAmeBLV}.png}


\subsection{minimum spanning trees.}
\label{\detokenize{Algorithmer/Graphs:minimum-spanning-trees}}
\sphinxAtStartPar
træer der har den mindste vægt fra 1 node ud til alle andre nodes i systemet.


\subsubsection{kruskals Algoritme}
\label{\detokenize{Algorithmer/Graphs:kruskals-algoritme}}
\sphinxAtStartPar
\sphinxincludegraphics{{KnNhvfN}.png}


\subsubsection{prims Algoritme}
\label{\detokenize{Algorithmer/Graphs:prims-algoritme}}
\sphinxAtStartPar
\sphinxincludegraphics{{IcjCMiY}.png}


\subsection{korteste vej ( shortest path ) Algoritmer}
\label{\detokenize{Algorithmer/Graphs:korteste-vej-shortest-path-algoritmer}}

\subsubsection{bellman\sphinxhyphen{}ford}
\label{\detokenize{Algorithmer/Graphs:bellman-ford}}
\sphinxAtStartPar
\sphinxincludegraphics{{yIyTBjj}.png}


\subsubsection{dijsktra}
\label{\detokenize{Algorithmer/Graphs:dijsktra}}
\sphinxAtStartPar
\sphinxincludegraphics{{AW5EJcA}.png}

\sphinxstepscope


\section{korrekthed af algoritmer}
\label{\detokenize{Algorithmer/Korrekthed:korrekthed-af-algoritmer}}\label{\detokenize{Algorithmer/Korrekthed::doc}}

\section{Horners rule}
\label{\detokenize{Algorithmer/Korrekthed:horners-rule}}
\sphinxAtStartPar
Det her er en dum måde at regne polynomier del by del

\sphinxAtStartPar
a\_0+x(a\_1+x(a\_2+x))


\section{}
\label{\detokenize{Algorithmer/Korrekthed:id1}}


\renewcommand{\indexname}{Indeks}
\printindex
\end{document}